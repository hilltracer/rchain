/**
 * Rholang Term Structure
 *
 * The top level is `Par`.
 */
syntax = "proto3";

// If you are building for other languages "scalapb.proto"
// can be manually obtained here:
// https://raw.githubusercontent.com/scalapb/ScalaPB/master/protobuf/scalapb/scalapb.proto
// make a scalapb directory in this file's location and place it inside

import "scalapb/scalapb.proto";

option (scalapb.options) = {
  package_name: "coop.rchain.models.protobuf"
  import: "coop.rchain.models.protobuf.BitSetBytesMapper.bitSetBytesMapper"
  import: "coop.rchain.models.protobuf.ParSetTypeMapper.parSetESetTypeMapper"
  import: "coop.rchain.models.protobuf.ParMapTypeMapper.parMapEMapTypeMapper"
  import: "coop.rchain.models.protobuf.BigIntTypeMapper.bigIntBytesTypeMapper"
  preserve_unknown_fields: false
};

/**
 * Rholang process
 *
 * For example, `@0!(1) | @2!(3) | for(x <- @0) { Nil }` has two sends
 * and one receive.
 *
 * The Nil process is a `Par` with no sends, receives, etc.
 */
message ParProto {
    repeated SendProto sends = 1;
    repeated ReceiveProto receives = 2;
    repeated NewProto news = 4;
    repeated ExprProto exprs = 5;
    repeated MatchProto matches = 6;
    repeated GUnforgeableProto unforgeables = 7;  // unforgeable names
    repeated BundleProto bundles = 11;
    repeated ConnectiveProto connectives = 8;
    bytes locallyFree = 9 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 10;
}

/**
 * Either rholang code or code built in to the interpreter.
 */
message TaggedContinuationProto {
    oneof tagged_cont {
        ParWithRandomProto par_body = 1;
        int64 scala_body_ref = 2;
    }
}

/**
 * Rholang code along with the state of a split random number
 * generator for generating new unforgeable names.
 */
message ParWithRandomProto {
    ParProto body = 1 [(scalapb.field).no_box = true];
    bytes randomState = 2 [(scalapb.field).type = "coop.rchain.crypto.hash.Blake2b512Random"];
}

/**
 * Cost of the performed operations.
 */
message PCostProto {
    uint64 cost = 1;
}

message ListParWithRandomProto {
    repeated ParProto pars = 1;
    bytes randomState = 2 [(scalapb.field).type = "coop.rchain.crypto.hash.Blake2b512Random"];
}

// While we use vars in both positions, when producing the normalized
// representation we need a discipline to track whether a var is a name or a
// process.
// These are DeBruijn levels
message VarProto {
    message WildcardMsgProto {}
    oneof var_instance {
        sint32 bound_var = 1;
        sint32 free_var = 2;
        WildcardMsgProto wildcard = 3;
    }
}

/**
 * Nothing can be received from a (quoted) bundle with `readFlag = false`.
 * Likeise nothing can be sent to a (quoted) bundle with `writeFlag = false`.
 *
 * If both flags are set to false, bundle allows only for equivalance check.
 */
message BundleProto {
    ParProto body = 1 [(scalapb.field).no_box = true];
    bool writeFlag = 2; // flag indicating whether bundle is writeable
    bool readFlag = 3; // flag indicating whether bundle is readable
}

/**
 * A send is written `chan!(data)` or `chan!!(data)` for a persistent send.
 *
 * Upon send, all free variables in data are substituted with their values.
 */
message SendProto {
    ParProto chan = 1 [(scalapb.field).no_box = true];
    repeated ParProto data = 2;
    bool persistent = 3;
    bytes locallyFree = 5 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 6;
}

message ReceiveBindProto {
    repeated ParProto patterns = 1;
    ParProto source = 2 [(scalapb.field).no_box = true];
    VarProto remainder = 3;
    int32 freeCount = 4;
}

message BindPatternProto {
    repeated ParProto patterns = 1;
    VarProto remainder = 2;
    int32 freeCount = 3;
}

message ListBindPatternsProto {
    repeated BindPatternProto patterns = 1;
}

/**
 * A receive is written `for(binds) { body }`
 * i.e. `for(patterns <- source) { body }`
 * or for a persistent recieve: `for(patterns <= source) { body }`.
 *
 * It's an error for free Variable to occur more than once in a pattern.
 */
message ReceiveProto {
    repeated ReceiveBindProto binds = 1;
    ParProto body = 2 [(scalapb.field).no_box = true];
    bool persistent = 3;
    bool peek = 4;
    int32 bindCount = 5;
    bytes locallyFree = 6 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 7;
}

// Number of variables bound in the new statement.
// For normalized form, p should not contain solely another new.
// Also for normalized form, the first use should be level+0, next use level+1
// up to level+count for the last used variable.
message NewProto {
    // Includes any uris listed below. This makes it easier to substitute or walk a term.
    sint32 bindCount = 1;
    ParProto p = 2 [(scalapb.field).no_box = true];
    // For normalization, uri-referenced variables come at the end, and in lexicographical order.
    repeated string uri = 3;
    map<string, ParProto> injections = 4;
    bytes locallyFree = 5 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
}

message MatchCaseProto {
    ParProto pattern = 1 [(scalapb.field).no_box = true];
    ParProto source = 2 [(scalapb.field).no_box = true];
    int32 freeCount = 3;
}

message MatchProto {
    ParProto target = 1 [(scalapb.field).no_box = true];
    repeated MatchCaseProto cases = 2;
    bytes locallyFree = 4 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 5;
}

// Any process may be an operand to an expression.
// Only processes equivalent to a ground process of compatible type will reduce.
message ExprProto {
    oneof expr_instance {
        bool g_bool = 1;
        sint64 g_int = 2;
        bytes g_big_int = 34 [(scalapb.field).type = "scala.math.BigInt"];
        string g_string = 3;
        string g_uri = 4;
        bytes g_byte_array = 25;

        ENotProto e_not_body = 5;
        ENegProto e_neg_body = 6;
        EMultProto e_mult_body = 7;
        EDivProto e_div_body = 8;
        EPlusProto e_plus_body = 9;
        EMinusProto e_minus_body = 10;
        ELtProto e_lt_body = 11;
        ELteProto e_lte_body = 12;
        EGtProto e_gt_body = 13;
        EGteProto e_gte_body = 14;
        EEqProto e_eq_body = 15;
        ENeqProto e_neq_body = 16;
        EAndProto e_and_body = 17;
        EOrProto e_or_body = 18;
        EVarProto e_var_body = 19;

        EListProto e_list_body = 20;
        ETupleProto e_tuple_body = 21;
        ESetProto e_set_body = 22 [(scalapb.field).type = "coop.rchain.models.protobuf.ParSetProto"];
        EMapProto e_map_body = 23 [(scalapb.field).type = "coop.rchain.models.protobuf.ParMapProto"];
        EMethodProto e_method_body = 24;

        EMatchesProto e_matches_body = 27;
        EPercentPercentProto e_percent_percent_body = 28; // string interpolation
        EPlusPlusProto e_plus_plus_body = 29; // concatenation
        EMinusMinusProto e_minus_minus_body = 30;  // set difference

        EModProto e_mod_body = 31;

        // short circuit boolean evaluation
        EShortAndProto e_short_and_body = 32;
        EShortOrProto  e_short_or_body = 33;
    }
}

message EListProto {
    repeated ParProto ps = 1;
    bytes locallyFree = 3 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 4;
    VarProto remainder = 5;
}

message ETupleProto {
    repeated ParProto ps = 1;
    bytes locallyFree = 3 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 4;
}

message ESetProto {
    repeated ParProto ps = 1;
    bytes locallyFree = 3 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 4;
    VarProto remainder = 5;
}

message EMapProto {
    repeated KeyValuePairProto kvs = 1;
    bytes locallyFree = 3 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 4;
    VarProto remainder = 5;
}

/**
 * `target.method(arguments)`
 */
message EMethodProto {
    string methodName = 1;
    ParProto target = 2 [(scalapb.field).no_box = true];
    repeated ParProto arguments = 3;
    bytes locallyFree = 5 [(scalapb.field).type = "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
    bool connective_used = 6;
}

message KeyValuePairProto {
    ParProto key = 1 [(scalapb.field).no_box = true];
    ParProto value = 2 [(scalapb.field).no_box = true];
}

// A variable used as a var should be bound in a process context, not a name
// context. For example:
// `for (@x <- c1; @y <- c2) { z!(x + y) }` is fine, but
// `for (x <- c1; y <- c2) { z!(x + y) }` should raise an error.
message EVarProto {
    VarProto v = 1 [(scalapb.field).no_box = true];
}

message ENotProto {
    ParProto p = 1 [(scalapb.field).no_box = true];
}

message ENegProto {
    ParProto p = 1 [(scalapb.field).no_box = true];
}

message EMultProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EDivProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EModProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EPlusProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EMinusProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message ELtProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message ELteProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EGtProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EGteProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EEqProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message ENeqProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EAndProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EOrProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EShortAndProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EShortOrProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message EMatchesProto {
    ParProto target = 1 [(scalapb.field).no_box = true];
    ParProto pattern = 2 [(scalapb.field).no_box = true];
}

/**
 * String interpolation
 *
 * `"Hello, ${name}" %% {"name": "Bob"}` denotes `"Hello, Bob"`
 */
message EPercentPercentProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

// Concatenation
message EPlusPlusProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

// Set difference
message EMinusMinusProto {
    ParProto p1 = 1 [(scalapb.field).no_box = true];
    ParProto p2 = 2 [(scalapb.field).no_box = true];
}

message ConnectiveProto {
  oneof connective_instance {
    ConnectiveBodyProto conn_and_body = 1;
    ConnectiveBodyProto conn_or_body = 2;
    ParProto conn_not_body = 3;
    VarRefProto var_ref_body = 4;
    bool conn_bool = 5;
    bool conn_int = 6;
    bool conn_big_int = 10;
    bool conn_string = 7;
    bool conn_uri = 8;
    bool conn_byte_array = 9;
  }
}

message VarRefProto {
  sint32 index = 1;
  sint32 depth = 2;
}

message ConnectiveBodyProto {
    repeated ParProto ps = 1;
}

message DeployIdProto {
     bytes sig = 1;
}

message DeployerIdProto {
    bytes publicKey = 1;
}

// Unforgeable names resulting from `new x { ... }`
// These should only occur as the program is being evaluated. There is no way in
// the grammar to construct them.
message GUnforgeableProto {
    oneof unf_instance {
        GPrivateProto g_private_body = 1;
        GDeployIdProto g_deploy_id_body = 2;
        GDeployerIdProto g_deployer_id_body = 3;
        GSysAuthTokenProto g_sys_auth_token_body = 4;
    }
}

message GPrivateProto {
    bytes id = 1;
}

message GDeployIdProto {
    bytes sig = 1;
}

message GDeployerIdProto {
    bytes publicKey = 1;
}

message GSysAuthTokenProto {}
